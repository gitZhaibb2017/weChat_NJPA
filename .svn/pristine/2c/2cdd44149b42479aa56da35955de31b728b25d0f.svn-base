/**
 * 
 */
package com.paic.pawj.answer.service.impl;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.paic.pawj.answer.common.contants.AnswerContants;
import com.paic.pawj.answer.common.contants.AnswerType;
import com.paic.pawj.answer.controller.vo.AnswersVO;
import com.paic.pawj.answer.dao.Answers;
import com.paic.pawj.answer.dao.AnswerRecord;
import com.paic.pawj.answer.dao.AnswersMapper;
import com.paic.pawj.answer.service.AnswersService;
import com.paic.pawj.basic.account.service.AccountChangeService;
import com.paic.pawj.common.util.ReturnConstants;
import com.paic.pawj.investigation.controller.vo.OptionAppVO;
import com.paic.pawj.investigation.controller.vo.QuestionAppVO;
import com.paic.pawj.investigation.dao.OptionQueryDTO;

@Service("answersService")
public class AnswersServiceImpl implements AnswersService {

	@Autowired
	private AccountChangeService accountChangeService;

	@Resource
	private AnswersMapper answersDao;

	@Override
	public void saveAnswers(Answers answers) {
		answersDao.saveAnswers(answers);
	}

	@Override
	public List<Map<String, Object>> queryQstnaireList() {
		return answersDao.queryQstnaireList();
	}

	@Override
	public String getQsrCompletionPercent(String qsrId) {
		int answersCount = answersDao.getAnswerUserCount(qsrId);
		Integer qsrNumber = answersDao.getQsrNumber(qsrId);

		String res = "0";
		String completionPercent = "";
		if (qsrNumber != null) {
			completionPercent = getPercent(answersCount, qsrNumber);
		}
		if (completionPercent.indexOf(".") > 0) {
			res = completionPercent.substring(0, completionPercent.indexOf("."));
		}
		return res;
	}

	private String getPercent(int x, int total) {
		String result = "";
		try {
			double x_double = x * 1.0;
			double tempres = x_double / total;
			DecimalFormat df1 = new DecimalFormat("0.00%");
			result = df1.format(tempres);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return result;
	}

	@Override
	@Transactional
	public JsonObject answers(List<AnswersVO> answersList, String userID, int completed) {
		JsonObject result = new JsonObject();
		String ivtgID = answersList.get(0).getQsrId();
		if (isNotAnswered(ivtgID, userID)) {
			Map<String, List<AnswersVO>> map = answersToMap(answersList);
			Answers answers = null;
			for (String key : map.keySet()) {
				answers = voToAnswers(map.get(key), userID);
				if (null != answers) {
					answersDao.saveAnswers(answers);
				}
			}

			if (1 == completed) {
				String investigationID = answersList.get(0).getQsrId();
				insertAnswerRecord(ivtgID, userID);
				accountChangeService.changeAccountByIvtg(userID, investigationID);
			}
			result.addProperty(ReturnConstants.CODE_KEY, ReturnConstants.NORMAL_CODE);
		} else {
			result.addProperty(ReturnConstants.CODE_KEY, "1001");
		}

		return result;

	}

	/**
	 * 
	 * @return
	 */
	private Map<String, List<AnswersVO>> answersToMap(List<AnswersVO> answersList) {
		Map<String, List<AnswersVO>> map = new HashMap<String, List<AnswersVO>>();
		List<AnswersVO> questionAnswers = null;
		for (AnswersVO vo : answersList) {
			if (map.containsKey(vo.getQstId())) {
				map.get(vo.getQstId()).add(vo);
			} else {
				questionAnswers = new ArrayList<AnswersVO>();
				questionAnswers.add(vo);
				map.put(vo.getQstId(), questionAnswers);
			}

		}
		return map;
	}

	private Answers voToAnswers(List<AnswersVO> list, String userID) {
		Answers answers = null;
//		if (CollectionUtils.isNotEmpty(list)) {
//			answers = new Answers();
//			StringBuilder content = new StringBuilder();
//			for (AnswersVO vo : list) {
//				content.append(vo.getAnswerContent());
//				content.append(';');
//				answers.setAnswerType(vo.getAnswerType());
//				answers.setQsrId(vo.getQsrId());
//				answers.setQstId(vo.getQstId());
//			}
//			content.deleteCharAt(content.lastIndexOf(";"));
//			answers.setAnswerContent(content.toString());
//			answers.setUserId(userID);
//		}

		return answers;
	}

	@Override
	public AnswerRecord getAnswerRecord(AnswerRecord answerRecord) {
		return answersDao.queryAnswerRecordByUser(answerRecord);
	}

	public boolean isNotAnswered(String ivtgID, String userID) {
		boolean res = false;
		AnswerRecord record = new AnswerRecord();
		record.setInvestigationID(ivtgID);
		record.setUserID(userID);
		AnswerRecord result = answersDao.queryAnswerRecordByUser(record);
		if (null == result) {
			res = true;
		}
		return res;
	}

	@Override
	public void insertAnswerRecord(String ivtgID, String userID) {
		addAnswerRecord(ivtgID, userID, "1");
	}

	/**
	 * 保存答题记录
	 * 
	 * @param ivtgID
	 * @param userID
	 */
	private void addAnswerRecord(String ivtgID, String userID, String status) {
		AnswerRecord record = new AnswerRecord();
		record.setInvestigationID(ivtgID);
		record.setUserID(userID);
		record.setAnswerStatus(status);
		answersDao.insertAnswerRecord(record);
	}

	@Override
	public Map<String, Object> getNextQuestionByParam(Answers param) {
		Map<String, Object> resultMap = new HashMap<String, Object>();
		// 当前问卷为首次进入，默认返回问卷第一题
		if (param.getQuestMark().equals(AnswerContants.FIRST_MARK)) {
			List<OptionQueryDTO> listOne = answersDao.getFirstQuestionOfQuestionNaire(param.getInvestigationId());
			resultMap = traverseOptionQueryList(listOne);
		} else {
			String nextQuestionId = null;
			//若当前题目为选择题时
			if(StringUtils.isNotBlank(param.getOptionId())){
			//多选题且答案不止一个时
			if (param.getQuestionType().equals(AnswerType.CHECK_TYPE_OPTION)
					|| param.getQuestionType().equals(AnswerType.PICTURE_CHECK_OPTION)
							&& param.getOptionId().indexOf(",") != -1) {
				String []a = param.getOptionId().split(",");
				for(int i=0;i<a.length;i++){
					nextQuestionId = answersDao.getQuestionIdByOption(a[i]);
					if(StringUtils.isNotBlank(nextQuestionId)){
						break;
					}
				}
				// 若关联associateID为空则表示，当前选项未关联其他题目，则按照原有题号顺序取得下一题
				resultMap = judgeTheNextAndBackTrack(nextQuestionId,param);
			} else {
				// 通过选项ID获取当前选项是否关联其他题目
				nextQuestionId = answersDao.getQuestionIdByOption(param.getOptionId());
				// 若关联associateID为空则表示，当前选项未关联其他题目，则按照原有题号顺序取得下一题
				resultMap = judgeTheNextAndBackTrack(nextQuestionId,param);
			}
			
		}else{//若当前题不是选择题时
			nextQuestionId = answersDao.getNextQuestionBySequence(param.getQuestionId());
			//若下一题的questionID为空则当前题目为最后一题
			if (StringUtils.isBlank(nextQuestionId)) {
				resultMap.put("questMark", AnswerContants.LAST_MARK);
				return resultMap;
			}
			List<OptionQueryDTO> list = answersDao.getNextQuestionByParam(nextQuestionId);
			resultMap = traverseOptionQueryList(list);
		}
	}
		return resultMap;

	}

	/**
	 * 保存答题答案-单题
	 */
	@Override
	public Map<String, Object> answerOne(Answers answer, String userId) {
		Map<String, Object> returnMap = null;
		// 如果是第一题，插入答题记录
		if (AnswerContants.FIRST_MARK.equals(answer.getQuestMark())) {
			// 插入答题记录，默认题目状态是0
			addAnswerRecord(answer.getQuestionId(), userId, AnswerContants.RECORD_ZERO);
		}
		// 保存答题项
		answersDao.insertAnswerOne(answer);
		// 根据答题选项获得下一题
		returnMap = getNextQuestionByParam(answer);
		// 如果是最后一题修改答题记录为答题结束
		if (AnswerContants.LAST_MARK.equals(answer.getQuestMark())) {
			Map<String, Object> paramMap = new HashMap<String, Object>();
			paramMap.put("investigationId", answer.getInvestigationId());
			paramMap.put("userId", userId);
			answersDao.updaterAnswerRecordEnd(paramMap);
		}
		return returnMap;
	}

	/**
	 * description:（抽取）遍历list公共方法
	 * 
	 * @param list
	 * @return
	 */
	public Map<String, Object> traverseOptionQueryList(List<OptionQueryDTO> list) {
		Map<String, Object> resultMap = new HashMap<String, Object>();
		QuestionAppVO questionVo = null;
		String lastQstID = null;
		OptionAppVO optionVO = null;
		for (OptionQueryDTO optionQueryDto : list) {
			if (!optionQueryDto.getQuestionID().equals(lastQstID)) {
				questionVo = new QuestionAppVO();
				questionVo.setQstId(optionQueryDto.getQuestionID());
				questionVo.setQsrId(optionQueryDto.getInvestigationID());
				questionVo.setQuestionName(optionQueryDto.getQuestionSubject());
				questionVo.setQuestionSeq(optionQueryDto.getQuestionSeq());
				questionVo.setQuestionType(optionQueryDto.getQuestionType());
				questionVo.setOptions(new ArrayList<OptionAppVO>());

				lastQstID = optionQueryDto.getQuestionID();
			}
			optionVO = new OptionAppVO(optionQueryDto);
			questionVo.getOptions().add(optionVO);
			Gson gson = new Gson();
			resultMap.put("detail", gson.toJsonTree(questionVo));
			resultMap.put("questMark", AnswerContants.USALLY_MARK);
		}
		return resultMap;
	}
	/**
	 * description: （抽离）判断选项是否关联下一题并返回resultMap方法
	 * @param nextQuestionId
	 * @param param
	 * @return
	 */
	public Map<String,Object> judgeTheNextAndBackTrack(String nextQuestionId,Answers param){
		Map<String, Object> resultMap = new HashMap<String, Object>();
		if(StringUtils.isBlank(nextQuestionId)){
			nextQuestionId = answersDao.getNextQuestionBySequence(param.getQuestionId());
			//若下一题的questionID为空则当前题目为最后一题
			if (StringUtils.isBlank(nextQuestionId)) {
				resultMap.put("questMark", AnswerContants.LAST_MARK);
				return resultMap;
			}
		}
		List<OptionQueryDTO> list = answersDao.getNextQuestionByParam(nextQuestionId);
		resultMap = traverseOptionQueryList(list);
		return resultMap;
		}

}
